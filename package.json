const express = require("express");
const cors = require("cors");
const fetch = require("node-fetch");
const { v4: uuidv4 } = require("uuid");
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

const app = express();
app.use(cors());
app.use(express.json({ limit: "25mb" }));

const PORT = process.env.PORT || 3000;

// ======================
// CONFIG
// ======================
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
// اختيارياً: لو عندك مزود TTS مثل ElevenLabs
const TTS_API_KEY = process.env.TTS_API_KEY || "";

// مسار حفظ الملفات
const OUT_DIR = path.join(__dirname, "output");
if (!fs.existsSync(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });

// “قاعدة بيانات” بسيطة بالذاكرة (Render قد يعيد التشغيل: الأفضل Persistent Disk لو تبغى)
const JOBS = new Map();

// ======================
// Helpers
// ======================
function mustHaveEnv(name, value) {
  if (!value) throw new Error(`Missing env var: ${name}`);
}

function safeJsonParse(str) {
  try { return JSON.parse(str); } catch (e) { return null; }
}

function nowISO() { return new Date().toISOString(); }

function writeFile(p, data) {
  fs.writeFileSync(p, data);
  return p;
}

// ======================
// 1) Generate original script (NO copyright)
// ======================
async function generateStoryAndShots({ topic, durationSec }) {
  mustHaveEnv("OPENAI_API_KEY", OPENAI_API_KEY);

  const system = `
You are a professional short-form film writer and director.
CRITICAL RULES:
- Must be fully original.
- Do NOT reference or resemble any real movie, TV show, book, artist, celebrity, or copyrighted work.
- Do NOT imitate any known creator’s style.
- Avoid brand names.
- Output must be valid JSON only.
`;

  const user = `
Create a highly realistic cinematic short video plan.
Topic: ${topic || "mystery found-footage style discovery (original)"}.
Target duration: ${durationSec || 45} seconds.

Return JSON with:
{
  "title": "...",
  "hook": "...(1 sentence)",
  "voiceover": "full voiceover script (no timestamps)",
  "shots": [
    {
      "id": 1,
      "description": "what we see",
      "camera": "camera movement + lens vibe",
      "lighting": "lighting",
      "imagePrompt": "photoreal prompt (no copyrighted refs)",
      "onScreenText": "short subtitle text",
      "seconds": 5
    }
  ],
  "style": {
    "visual": "photoreal, cinematic, high detail, realistic",
    "musicTags": ["..."],
    "safety": "no copyright references"
  }
}

Constraints:
- 7 to 10 shots maximum.
- Each shot seconds sum ~ target duration.
- imagePrompt must be ultra-detailed photoreal, with camera terms, but NO references to real works/people.
`;

  const body = {
    model: "gpt-4.1-mini",
    messages: [
      { role: "system", content: system.trim() },
      { role: "user", content: user.trim() }
    ],
    response_format: { type: "json_object" }
  };

  const r = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${OPENAI_API_KEY}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });

  if (!r.ok) {
    const t = await r.text();
    throw new Error(`OpenAI story error: ${r.status} ${t}`);
  }

  const data = await r.json();
  const content = data.choices?.[0]?.message?.content || "{}";
  const json = safeJsonParse(content);
  if (!json) throw new Error("Model did not return valid JSON.");

  return json;
}

// ======================
// 2) Generate images (placeholder)
// ======================
// ملاحظة: توليد الصور يعتمد على مزود عندك.
// هنا حاط وظيفة "وهمية" ترجع صورة افتراضية.
// تقدر تربطها بـ OpenAI Images API أو أي مزود صور تفضله.
async function generateImagePlaceholder(jobDir, idx) {
  // صورة سوداء بسيطة كبديل (عشان السكربت يشتغل حتى بدون مزود صور)
  const pngPath = path.join(jobDir, `shot_${idx}.png`);
  // نحتاج ffmpeg لعمل png أسود (بدون أدوات رسم)
  execSync(`ffmpeg -y -f lavfi -i color=c=black:s=1080x1920:d=0.1 -frames:v 1 "${pngPath}"`);
  return pngPath;
}

// ======================
// 3) Generate voiceover audio (placeholder)
// ======================
// إذا عندك مزود TTS، اربطه هنا.
// الآن: نعمل silent audio بنفس طول الفيديو (عشان الـ ffmpeg ما يفشل)
function generateSilentAudio(jobDir, seconds) {
  const wavPath = path.join(jobDir, "voiceover.wav");
  execSync(`ffmpeg -y -f lavfi -i anullsrc=r=44100:cl=stereo -t ${seconds} "${wavPath}"`);
  return wavPath;
}

// ======================
// 4) Make video with ffmpeg
// ======================
function makeVideoFromImages(jobDir, imagePaths, voicePath, totalSeconds) {
  // نعمل فيديو عمودي 1080x1920
  // نوزع الزمن على عدد الصور بالتساوي (أو تقدر تعمل حسب shot.seconds)
  const per = Math.max(1, Math.floor(totalSeconds / imagePaths.length));
  const listPath = path.join(jobDir, "images.txt");
  const lines = imagePaths.map(p => `file '${p.replace(/'/g, "'\\''")}'\nduration ${per}`).join("\n") + "\n";
  fs.writeFileSync(listPath, lines);

  const outVideo = path.join(jobDir, "final.mp4");

  // concat images -> video
  // ملاحظة: آخر صورة لازم تنعاد بدون duration حتى ffmpeg ما يعلق
  // لذلك نضيف آخر file بدون duration:
  fs.appendFileSync(listPath, `file '${imagePaths[imagePaths.length - 1].replace(/'/g, "'\\''")}'\n`);

  execSync(
    `ffmpeg -y -f concat -safe 0 -i "${listPath}" -i "${voicePath}" ` +
    `-vf "scale=1080:1920:force_original_aspect_ratio=cover,crop=1080:1920" ` +
    `-c:v libx264 -pix_fmt yuv420p -c:a aac -shortest "${outVideo}"`
  );

  return outVideo;
}

// ======================
// Job Runner
// ======================
async function runJob(jobId, payload) {
  const job = JOBS.get(jobId);
  const jobDir = path.join(OUT_DIR, jobId);
  if (!fs.existsSync(jobDir)) fs.mkdirSync(jobDir, { recursive: true });

  try {
    job.status = "running";
    job.updatedAt = nowISO();

    const plan = await generateStoryAndShots({
      topic: payload?.topic,
      durationSec: payload?.durationSec || 45
    });

    writeFile(path.join(jobDir, "plan.json"), JSON.stringify(plan, null, 2));

    // صور (placeholder الآن)
    const imagePaths = [];
    for (let i = 0; i < plan.shots.length; i++) {
      const img = await generateImagePlaceholder(jobDir, i + 1);
      imagePaths.push(img);
    }

    // صوت (silent placeholder)
    const totalSeconds = plan.shots.reduce((a, s) => a + (s.seconds || 5), 0);
    const voice = generateSilentAudio(jobDir, totalSeconds);

    // فيديو
    const videoPath = makeVideoFromImages(jobDir, imagePaths, voice, totalSeconds);

    job.status = "done";
    job.updatedAt = nowISO();
    job.result = {
      title: plan.title,
      hook: plan.hook,
      downloadUrl: `/api/download/${jobId}`,
      planUrl: `/api/status/${jobId}`
    };
  } catch (e) {
    job.status = "error";
    job.updatedAt = nowISO();
    job.error = String(e?.message || e);
  }
}

// ======================
// Routes
// ======================
app.get("/", (req, res) => res.send("Short Video API is running ✅"));

app.post("/api/short-video", (req, res) => {
  const id = uuidv4();
  JOBS.set(id, {
    id,
    status: "queued",
    createdAt: nowISO(),
    updatedAt: nowISO(),
    result: null,
    error: null
  });

  // تشغيل بدون انتظار
  runJob(id, req.body);

  res.json({
    ok: true,
    id,
    statusUrl: `/api/status/${id}`,
    message: "Job queued"
  });
});

app.get("/api/status/:id", (req, res) => {
  const job = JOBS.get(req.params.id);
  if (!job) return res.status(404).json({ ok: false, error: "Not found" });
  res.json({ ok: true, ...job });
});

app.get("/api/download/:id", (req, res) => {
  const id = req.params.id;
  const jobDir = path.join(OUT_DIR, id);
  const videoPath = path.join(jobDir, "final.mp4");
  if (!fs.existsSync(videoPath)) return res.status(404).send("Video not found");
  res.download(videoPath, `video_${id}.mp4`);
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
